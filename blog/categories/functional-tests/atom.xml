<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: functional-tests | !geek]]></title>
  <link href="http://tech.endeepak.com/blog/categories/functional-tests/atom.xml" rel="self"/>
  <link href="http://tech.endeepak.com/"/>
  <updated>2014-07-30T23:50:27+05:30</updated>
  <id>http://tech.endeepak.com/</id>
  <author>
    <name><![CDATA[Deepak Narayana Rao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Using app objects in multi app functional tests]]></title>
    <link href="http://tech.endeepak.com/blog/2014/07/27/using-app-objects-in-multi-app-functional-tests"/>
    <updated>2014-07-27T18:40:04+05:30</updated>
    <id>http://tech.endeepak.com/blog/2014/07/27/using-app-objects-in-multi-app-functional-tests</id>
    <content type="html"><![CDATA[<p>It is better to create small modular apps instead of single monolithic application. In <a href="http://www.bahmni.org">Bahmni EMR</a> we have small apps for Patient Registration, Consultation, etc. An end to end <a href="https://github.com/Bhamni/emr-functional-tests/tree/master/spec">functional test</a> covering patient registration and consultation goes through multiple apps. We needed to abstract the concept of an app in test code to increase the readability and maintainability.</p>

<p>The app objects are natural extension of <a href="https://code.google.com/p/selenium/wiki/PageObjects">page objects</a> recommended for writing functional tests. An app encapsulates all pages and coarse level actions in the app.</p>

<!-- More -->


<p>An simple implementation of app class would be</p>

<p>```ruby registration/app.rb
class Registration::App</p>

<pre><code># Pages in this apps    
def patient_page
    Registration::PatientPage.new
end

def visit_details_page
    Registration::VisitDetailsPage.new
end

# Coarse level action in this app
def register_new_patient(options)
    click_link "Create New"
    patient_page.fill(options[:patient]).start_visit(options[:visit_type])
end
</code></pre>

<p>end
```
The test using this simple implementation would look like</p>

<p>```ruby
registration = Registration::App.new
registration.register_new_patient :patient => new_patient, :visit_type => &lsquo;OPD&rsquo;
registration.visit_page.should_be_current_page
registration.visit_page.save_new_patient_visit(visit_info)</p>

<p>clinical = Clinical::App.new
clinical.patient_search_page.should_have_active_patient(new_patient)
clinical.patient_search_page.view_patient(new_patient)
```</p>

<p>The <a href="https://github.com/Bhamni/emr-functional-tests/tree/master/spec">test code</a> is structured as</p>

<pre>
apps
    registration
        app.rb
        patient_page.rb
        visit_details_page.rb
    clinical
        app.rb
        patient_search_page.rb
features
    new_patient_visit.rb
framework
    app.rb # Base class for other apps
    page.rb # Base class for other pages
</pre>


<h3>Nicer DSL</h3>

<p>We are using capybara and Rspec. The lambda syntax, meta programming constructs in ruby and convention based programming allowed us to implement a DSL shown below. The complete code can be found <a href="https://github.com/Bhamni/emr-functional-tests/tree/master/spec">here</a></p>

<p>```ruby
feature &ldquo;new patient visit&rdquo; do</p>

<pre><code>background { login('superuser', 'password') }

scenario "registration and consultation" do
    new_patient = {:given_name =&gt; "Ram", :family_name =&gt; 'Singh'}

    go_to_app(:registration) do
        register_new_patient(:patient =&gt; new_patient, :visit_type =&gt; 'OPD')
        visit_page.should_be_current_page
        visit_page.save_new_patient_visit(visit_info)
    end

    go_to_app(:clinical) do
        patient_search_page.should_have_active_patient(new_patient)
        patient_search_page.view_patient(new_patient)
        # ....
    end
end
</code></pre>

<p>end
```</p>

<p>I didn&rsquo;t into details of implementing the DSL. If people are interested, I can write a part 2 of this post.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Make sure functional tests are user centric]]></title>
    <link href="http://tech.endeepak.com/blog/2014/07/27/make-sure-functional-tests-are-user-centric"/>
    <updated>2014-07-27T16:43:49+05:30</updated>
    <id>http://tech.endeepak.com/blog/2014/07/27/make-sure-functional-tests-are-user-centric</id>
    <content type="html"><![CDATA[<p>In modern day web applications, most of the data is fetched and saved using ajax calls and the mark up is generated on client side by compiling static HTML templates. The functional tests need to make sure assertions wait till completion of ajax call.</p>

<p>Couple of bad ways to achieve this is by using <code>sleep(xSeconds)</code> or <code>wait_for_ajax</code> like this</p>

<!-- More -->


<p>``` ruby
fiil_in &lsquo;name&rsquo;, :with => &lsquo;foo&rsquo; # you might be using a page object pattern in real code
click_on &lsquo;Save&rsquo;
wait_for_ajax
expect(find(&lsquo;#number_of_people&rsquo;).text).to be(10)</p>

<h1>The implementation of wait_for_ajax which depends on jQuery.active</h1>

<p>def wait_for_ajax</p>

<pre><code>wait_until { page.evaluate_script('jQuery.active') == 0 }
</code></pre>

<p>end
```</p>

<p>The <code>sleep(xSeconds)</code> makes your tests indeterministic and <code>wait_for_ajax</code> makes it dependent on javascript framework used in application.</p>

<h2>Solution 1 : Choose a good framework</h2>

<p>Frameworks like capybara have implicit wait mechanism which eliminates the need for <code>wait_for_ajax</code></p>

<p><code>ruby
click_on 'Save'
expect(find('#number_of_people').to have_content(10) # Implicit wait
</code></p>

<p>But what happens when</p>

<ul>
<li>You are not using framework like capybara <em>or</em></li>
<li>The assertion is done on data saved in a database or file system</li>
</ul>


<p> In these cases, don&rsquo;t go back to <code>wait_for_ajax</code> or <code>sleep</code> solutions. Instead of depending on technical details of the app, you need to think in terms of</p>

<blockquote><p>How does the user know app is done loading or saving data?</p></blockquote>

<p>This will give you a hint on any missing usability requirements in the app.</p>

<h2>Solution 2 : Think like a user</h2>

<p>When you think like user, you will realize there must be a visual clue in the app to indicate the progress. The functional tests should also depend on this indicator (like a spinner, overlay etc) to figure out when to assert on data.</p>

<p>``` ruby</p>

<h1>click</h1>

<p>wait_for_completion</p>

<h1>assert</h1>

<h1>Example implementation of wait_for_completion</h1>

<p>def wait_for_completion</p>

<pre><code>wait_until { page.find('#loading-indicator').visible? == false }
</code></pre>

<p>end
```</p>

<p>When your tests are written from point of view of the user, they provide valuable feedback on the user experience.</p>
]]></content>
  </entry>
  
</feed>
